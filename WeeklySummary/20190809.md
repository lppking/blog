# 20190809
## 一、Hybird App
Hybird App，混合模式移动应用。它是在移动端介于**native app**和**web app**之间或者说是把这两者的优势结合起来的一种移动端应用的**开发模式**。就我个人的理解，native app 和hybird app是**一个core与多个branch**的关系。这种关系源于两者的优势，native app不用多说，原生应用天生具有良好的交互体验（页面加载速度快，交互流畅等），所以native app适用于承载核心业务（用户访问量大，交互较多）。而hybird app就是为了弥补native app在某些方面的不足诞生的，比如需要频繁发布更新的业务，需要节省开发成本，实现跨端（安卓+ Ios）的业务。
每一种技术的出现都源于需求，在**webview + js**（性能问题）和**react native**（坑太多，物料缺乏）都无法完美替代native app的情况下，**native app + hybird app**共同开发的模式将会长期存在，但是我个人觉得，**开发一套代码编译后实现多端无差异运行才是移动端开发的主流和趋势**。

## 二、有关移动端倒计时的实现
倒计时这个东西很常见了，主要做pc端开发的同学也不会觉得这个东西多么复杂，甚至可以说是比较简单了。但是有关倒计时业务我还是在实际的工作遇到了一些问题，也引发了我的一些思考。
### 1. 倒计时应该以什么时间作为基准？
开发中常用的时间来源包括两个：本地时间和服务端时间。这两者不同之处体现在两个地方：**准确性，实时性**。
首先说准确性。本地时间是不准确的，因为本地时间可以修改。服务端时间我们可以认为他是准确的。
而实时性，就是对于每一个时刻而言，时间是否准确。由此可见，服务端时间不具有实时性，因为从请求响应回来之后到下一次发送请求之间的这段时间，这个服务端时间只能我们自己维护（自己维护也是有问题的）。而本地时间具有好的实时性，因为我们每次使用都可以拿一次当前时间。

### 2. 倒计时实现的几种思路
这里假设服务端返回了两个时间，一个当前时间，一个到期时间。
#### 2.1 定时器加服务端时间
这种实现方式核心点就是开一个定时器，根据需要的时延（比如时间显示到秒，就是1000ms执行一次定时器），在每次定时器执行时更新时间，同时在服务端时间上减去响应的时间。但是这种实现方式存在两个明显问题：

 - 一是网络时延较大时拿到的服务端时间存在误差的问题，在网络时延较大时最为明显
 - 二是在ios端，当手指滑动屏幕时，页面的定时器会暂停，并且在重新开始倒计时后不会自动弥补误差

#### 2.2 定时器加本地时间
这种实现方式也是开一个定时器，设置固定的时延，每次定时器执行时获取当前时间，与到期时间算出一个差值，因为到期时间是固定的时间，所以这种方式计算出来的差值相对于当前的本地时间是很准确的。这种实现方式的好处就是**时间准确，我们可以忽略因为网络时延，页面卡顿，ios端定时器暂停等问题造成的服务端开始时间维护困难的问题。**
但是这种实现方式所有的好处都是基于**本地时间是准确的**这个大前提的。如果本地时间不准确，那么就谈不上任何准确了。

#### 2.3 定时器加本地时间加服务端时间
这种实现是在定时器加本地时间的基础上，针对本地时间可能不准确的问题做了一个弥补措施，思路就是在拿到服务端返回的时间后，用服务端的开始时间和当前本地时间算一个差值，然后在每次定时器执行时拿到本地时间后抛去这个差值，就可以获得准确的当前时间。这种方式可以说是比上面的两种方式都要更好，即兼顾了时间的实时性，又能做到准确。
但是，这只是针对理想情况而言的，最大的变数仍然是用户。想象这么一种情况：我们根据上面的方式实现了一个倒计时，这个倒计时正在进行，此时用户修改了系统时间，那么我们的本地时间又变了，那么在刚开始算的差值就又没有意义了。

那么，到底有没有一种方式既能兼顾准确性和实时性，又可以排除用户修改本地时间引发的问题呢？

这里我说一个我的思路：**误差监测 + 时间纠正**机制。

基于2.3的模式（解决了兼顾准确性和实时性的问题），其实需要的解决的问题就是排除用户操作的影响，这时我们就需要一个**误差监测**，比如我们是一秒执行一次，每次执行定时器就把上一次存储的当前时间和这一次的对比，如果两者差值大于1000，我们就认为时间出现了误差，此时就调用**时间纠正机制**，也就是再向服务器发送一次请求，获取一次准确的时间，重新走2.3的逻辑。
这种方式我还没有写代码去实现它（时间关系）。但是我觉得应该是可行的，当然还是可以有优化点的，比如两者差值，不一定非要不一样就请求服务端时间，可以采用一个积累值，比如误差大于10秒，再纠正时间，具体可以结合使用场景做调整。