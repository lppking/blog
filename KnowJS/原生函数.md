## 原生函数

原生函数，即JavaScript的内建函数（built-in function）。常用的原生函数有String()、Number()、Boolean()、Array()、Object()、Function()、RegExp()、Date()、Error()、Symbol()。

---

#### 一：内部属性[[Class]]

相信大家都知道如下所示的这种使用new操作符来调用原生函数的方式：

```
var str1 = new String('abc');
```
这种方式在日常开发中很少会显式用到，但是隐式调用却很多，如下所示这种情况就是很典型的一种隐式调用：
```
var str2 = 'abc';
str2.split('');
```
就是当我们将一个基本类型的值要当做对象去用的时候，JS引擎会自动调用对应类型的內建函数将这个基本类型的值转为对象，这是一个隐性操作。

那么str1和str2有什么区别呢？我们用typeof试一试：
```
typeof str1;    // 'object'
typeof str2;    // 'string'
```
通过这一点，我们就知道，调用new String()返回了一个String类型的对象。但是为什么**typeof str1**这个操作为什么没有返回'String'。是的，typeof并不能告诉你这个对象时什么类型，这就需要用到内部属性[[Class]]了。

**所有typeof返回值为"object"的对象都包含一个内部属性[[Class]]**。但是这个属性我们没办法直接访问，但可以间接访问：
```
Object.prototype.toString.call(str1);   // "[object String]"
Object.prototype.toString.call(str2);   // "[object String]"
```
这样就很明了了，打印结果的"String"就是这个内部属性[[Class]]的值了。那么为什么str2也是一样的结果呢？是的，隐式转换了。

---

#### 二：封装对象

这里所说的封装对象，其实就是使用new操作符调用原生函数生成的对象。在第一部分中说到隐式转换也提到了这部分的内容。

之所以需要封装对象，也很好理解。第一部分也有提到，基本类型时不具备方法的，方法都绑定在封装对象上。当然我们在开发中感受不到这个差异，是因为JS引擎在我们**将一个存储着基本类型值得变量当做封装对象使用时自动生成了一个封装对象来调用对应方法，然后在调用完毕后就立即将这个对象销毁了**。JS引擎针对这个过程做了优化，所以我们并不需要手动进行相关转换来提升性能。

谈到封装对象，就会涉及到封装对象的拆封问题，JS给我们提供了一个valueOf()方法，来获得封装对象的基本类型值：
```
var a = new String('abc');
a.valueOf();    // 'abc'
```

---

#### 三：什么时候使用原生构造函数

在大多数情况下，都不推荐使用原生构造函数，除了Date()和Error()。其他原生函数都有相应的字面量形式可以简洁高效的声明。但是Date和Error没有。